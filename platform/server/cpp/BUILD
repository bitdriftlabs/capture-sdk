load("@cxx.rs//tools/bazel:rust_cxx_bridge.bzl", "rust_cxx_bridge")
load("@rules_cc//cc:defs.bzl", "cc_binary")
load("@rules_rust//cargo:defs.bzl", "cargo_build_script")
load("@crates//:defs.bzl", "aliases", "all_crate_deps")
load("//bazel:bitdrift_build_system.bzl", "bitdrift_rust_library")

cc_binary(
    name = "capture",
    linkopts = ["-lz"] + select({
        "@platforms//os:linux": ["-Wl,--retain-symbols-file=$(location :symbols.lds)"],
        "@platforms//os:macos": [
            "-Wl,-exported_symbol,__ZNK6Logger*",
            "-Wl,-exported_symbol,__Z10new_logger*",
            "-Wl,-exported_symbol,__ZN4rust*",
        ],
        "//conditions:default": ["@platforms//:incompatible"],
    }) + select({
        "//bazel:dbg_build": ["-Wl,--build-id"],
        "//conditions:default": [],
    }),
    linkshared = True,
    tags = [
        "no-cache",
        "no-remote",
    ],
    visibility = ["//visibility:public"],
    deps = [
        "symbols.lds",
        ":platform-linux",
        ":cxx_bridge_linked",
    ],
)

rust_cxx_bridge(
    name = "cxx_bridge",
    src = "src/lib.rs",
    visibility = ["//visibility:public"],
)

# We need to make sure to link the .cc file generated by the cxx bridge
# into the final binary. Hence why we need this extra function that is the same
# as what rust_cxx_bridge generates, but with the alwayslink attribute set to True.
cc_library(
    name = "cxx_bridge_linked",
    srcs = ["src/lib.rs.cc"],
    hdrs = ["src/lib.rs.h"],
    includes = ["."],
    deps = [":cxx_bridge/include"],
    visibility = ["//visibility:public"],
    alwayslink = True,
)

bitdrift_rust_library(
    name = "platform-linux",
    srcs = glob(["src/**/*.rs"]),
    visibility = ["//visibility:public"],
    deps = [
        "//platform/shared:platform-shared",
    ],
    alwayslink = True,
)
