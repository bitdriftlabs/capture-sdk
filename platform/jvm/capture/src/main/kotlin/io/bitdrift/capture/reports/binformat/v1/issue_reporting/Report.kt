// capture-sdk - bitdrift's client SDK
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code is governed by a source available license that can be found in the
// LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// automatically generated by the FlatBuffers compiler, do not modify

package io.bitdrift.capture.reports.binformat.v1.issue_reporting

import com.google.flatbuffers.Constants
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import java.nio.ByteBuffer
import java.nio.ByteOrder

@Suppress("unused")
class ReportType private constructor() {
    companion object {
        const val Unknown: Byte = 0
        const val AppNotResponding: Byte = 1
        const val HandledError: Byte = 2
        const val JVMCrash: Byte = 3
        const val MemoryTermination: Byte = 4
        const val NativeCrash: Byte = 5
        const val StrictModeViolation: Byte = 6
        const val JavaScriptNonFatalError: Byte = 7
        const val JavaScriptFatalError: Byte = 8
    }
}

@Suppress("unused")
class Platform private constructor() {
    companion object {
        const val Unknown: Byte = 0
        const val Android: Byte = 1
        const val iOS: Byte = 2
        const val macOS: Byte = 3
    }
}

@Suppress("unused")
class Architecture private constructor() {
    companion object {
        const val Unknown: Byte = 0
        const val arm32: Byte = 1
        const val arm64: Byte = 2
        const val x86: Byte = 3
        const val x86_64: Byte = 4
    }
}

@Suppress("unused")
class FrameType private constructor() {
    companion object {
        const val Unknown: Byte = 0
        const val JVM: Byte = 1
        const val DWARF: Byte = 2
        const val AndroidNative: Byte = 3
        const val JavaScript: Byte = 4
    }
}

@Suppress("unused")
class ErrorRelation private constructor() {
    companion object {
        const val CausedBy: Byte = 1
    }
}

@Suppress("unused")
class PowerState private constructor() {
    companion object {
        const val Unknown: Byte = 0
        const val RunningOnBattery: Byte = 1
        const val PluggedInNoBattery: Byte = 2
        const val PluggedInCharging: Byte = 3
        const val PluggedInCharged: Byte = 4
    }
}

@Suppress("unused")
class NetworkState private constructor() {
    companion object {
        const val Unknown: Byte = 0
        const val Disconnected: Byte = 1
        const val Cellular: Byte = 2
        const val WiFi: Byte = 3
    }
}

@Suppress("unused")
class JavaScriptEngine private constructor() {
    companion object {
        const val UnknownJsEngine: Byte = 0
        const val JavaScriptCore: Byte = 1
        const val Hermes: Byte = 2
    }
}

@Suppress("unused")
class Rotation private constructor() {
    companion object {
        const val Unknown: Byte = 0
        const val Portrait: Byte = 1
        const val LandscapeRight: Byte = 2
        const val LandscapeLeft: Byte = 3
        const val PortraitUpsideDown: Byte = 4
    }
}

@Suppress("unused")
class FrameStatus private constructor() {
    companion object {
        const val Missing: Byte = 0
        const val Symbolicated: Byte = 1
        const val MissingSymbol: Byte = 2
        const val UnknownImage: Byte = 3
        const val Malformed: Byte = 4
    }
}

@Suppress("unused")
class Timestamp : Struct() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): Timestamp {
        __init(_i, _bb)
        return this
    }

    val seconds: ULong get() = bb.getLong(bb_pos + 0).toULong()
    val nanos: UInt get() = bb.getInt(bb_pos + 8).toUInt()

    companion object {
        fun createTimestamp(
            builder: FlatBufferBuilder,
            seconds: ULong,
            nanos: UInt,
        ): Int {
            builder.prep(8, 16)
            builder.pad(4)
            builder.putInt(nanos.toInt())
            builder.putLong(seconds.toLong())
            return builder.offset()
        }
    }
}

@Suppress("unused")
class Memory : Struct() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): Memory {
        __init(_i, _bb)
        return this
    }

    val total: ULong get() = bb.getLong(bb_pos + 0).toULong()
    val free: ULong get() = bb.getLong(bb_pos + 8).toULong()
    val used: ULong get() = bb.getLong(bb_pos + 16).toULong()

    companion object {
        fun createMemory(
            builder: FlatBufferBuilder,
            total: ULong,
            free: ULong,
            used: ULong,
        ): Int {
            builder.prep(8, 24)
            builder.putLong(used.toLong())
            builder.putLong(free.toLong())
            builder.putLong(total.toLong())
            return builder.offset()
        }
    }
}

@Suppress("unused")
class AppBuildNumber : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): AppBuildNumber {
        __init(_i, _bb)
        return this
    }

    val versionCode: Long
        get() {
            val o = __offset(4)
            return if (o != 0) bb.getLong(o + bb_pos) else 0L
        }
    val cfBundleVersion: String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val cfBundleVersionAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(6, 1)

    fun cfBundleVersionInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsAppBuildNumber(_bb: ByteBuffer): AppBuildNumber = getRootAsAppBuildNumber(_bb, AppBuildNumber())

        fun getRootAsAppBuildNumber(
            _bb: ByteBuffer,
            obj: AppBuildNumber,
        ): AppBuildNumber {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createAppBuildNumber(
            builder: FlatBufferBuilder,
            versionCode: Long,
            cfBundleVersionOffset: Int,
        ): Int {
            builder.startTable(2)
            addVersionCode(builder, versionCode)
            addCfBundleVersion(builder, cfBundleVersionOffset)
            return endAppBuildNumber(builder)
        }

        fun startAppBuildNumber(builder: FlatBufferBuilder) = builder.startTable(2)

        fun addVersionCode(
            builder: FlatBufferBuilder,
            versionCode: Long,
        ) = builder.addLong(0, versionCode, 0L)

        fun addCfBundleVersion(
            builder: FlatBufferBuilder,
            cfBundleVersion: Int,
        ) = builder.addOffset(1, cfBundleVersion, 0)

        fun endAppBuildNumber(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class ProcessorUsage : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): ProcessorUsage {
        __init(_i, _bb)
        return this
    }

    val durationSeconds: ULong
        get() {
            val o = __offset(4)
            return if (o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    val usedPercent: UByte
        get() {
            val o = __offset(6)
            return if (o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsProcessorUsage(_bb: ByteBuffer): ProcessorUsage = getRootAsProcessorUsage(_bb, ProcessorUsage())

        fun getRootAsProcessorUsage(
            _bb: ByteBuffer,
            obj: ProcessorUsage,
        ): ProcessorUsage {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createProcessorUsage(
            builder: FlatBufferBuilder,
            durationSeconds: ULong,
            usedPercent: UByte,
        ): Int {
            builder.startTable(2)
            addDurationSeconds(builder, durationSeconds)
            addUsedPercent(builder, usedPercent)
            return endProcessorUsage(builder)
        }

        fun startProcessorUsage(builder: FlatBufferBuilder) = builder.startTable(2)

        fun addDurationSeconds(
            builder: FlatBufferBuilder,
            durationSeconds: ULong,
        ) = builder.addLong(0, durationSeconds.toLong(), 0)

        fun addUsedPercent(
            builder: FlatBufferBuilder,
            usedPercent: UByte,
        ) = builder.addByte(1, usedPercent.toByte(), 0)

        fun endProcessorUsage(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class AppMetrics : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): AppMetrics {
        __init(_i, _bb)
        return this
    }

    val appId: String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val appIdAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(4, 1)

    fun appIdInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)

    val memory: io.bitdrift.capture.reports.binformat.v1.issue_reporting.Memory? get() =
        memory(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .Memory(),
        )

    fun memory(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.Memory,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.Memory? {
        val o = __offset(6)
        return if (o != 0) {
            obj.__assign(o + bb_pos, bb)
        } else {
            null
        }
    }

    val version: String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val versionAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(8, 1)

    fun versionInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)

    val buildNumber: io.bitdrift.capture.reports.binformat.v1.issue_reporting.AppBuildNumber? get() =
        buildNumber(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .AppBuildNumber(),
        )

    fun buildNumber(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.AppBuildNumber,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.AppBuildNumber? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    val runningState: String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val runningStateAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(12, 1)

    fun runningStateInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)

    val processId: UInt
        get() {
            val o = __offset(14)
            return if (o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val regionFormat: String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val regionFormatAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(16, 1)

    fun regionFormatInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)

    val cpuUsage: io.bitdrift.capture.reports.binformat.v1.issue_reporting.ProcessorUsage? get() =
        cpuUsage(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .ProcessorUsage(),
        )

    fun cpuUsage(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.ProcessorUsage,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.ProcessorUsage? {
        val o = __offset(18)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    val lifecycleEvent: String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val lifecycleEventAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(20, 1)

    fun lifecycleEventInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)

    val javascriptEngine: Byte
        get() {
            val o = __offset(22)
            return if (o != 0) bb.get(o + bb_pos) else 0
        }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsAppMetrics(_bb: ByteBuffer): AppMetrics = getRootAsAppMetrics(_bb, AppMetrics())

        fun getRootAsAppMetrics(
            _bb: ByteBuffer,
            obj: AppMetrics,
        ): AppMetrics {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun startAppMetrics(builder: FlatBufferBuilder) = builder.startTable(10)

        fun addAppId(
            builder: FlatBufferBuilder,
            appId: Int,
        ) = builder.addOffset(0, appId, 0)

        fun addMemory(
            builder: FlatBufferBuilder,
            memory: Int,
        ) = builder.addStruct(1, memory, 0)

        fun addVersion(
            builder: FlatBufferBuilder,
            version: Int,
        ) = builder.addOffset(2, version, 0)

        fun addBuildNumber(
            builder: FlatBufferBuilder,
            buildNumber: Int,
        ) = builder.addOffset(3, buildNumber, 0)

        fun addRunningState(
            builder: FlatBufferBuilder,
            runningState: Int,
        ) = builder.addOffset(4, runningState, 0)

        fun addProcessId(
            builder: FlatBufferBuilder,
            processId: UInt,
        ) = builder.addInt(5, processId.toInt(), 0)

        fun addRegionFormat(
            builder: FlatBufferBuilder,
            regionFormat: Int,
        ) = builder.addOffset(6, regionFormat, 0)

        fun addCpuUsage(
            builder: FlatBufferBuilder,
            cpuUsage: Int,
        ) = builder.addOffset(7, cpuUsage, 0)

        fun addLifecycleEvent(
            builder: FlatBufferBuilder,
            lifecycleEvent: Int,
        ) = builder.addOffset(8, lifecycleEvent, 0)

        fun addJavascriptEngine(
            builder: FlatBufferBuilder,
            javascriptEngine: Byte,
        ) = builder.addByte(9, javascriptEngine, 0)

        fun endAppMetrics(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class OSBuild : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): OSBuild {
        __init(_i, _bb)
        return this
    }

    val version: String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val versionAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(4, 1)

    fun versionInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)

    val brand: String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val brandAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(6, 1)

    fun brandInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)

    val fingerprint: String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val fingerprintAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(8, 1)

    fun fingerprintInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)

    val kernOsversion: String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val kernOsversionAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(10, 1)

    fun kernOsversionInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsOSBuild(_bb: ByteBuffer): OSBuild = getRootAsOSBuild(_bb, OSBuild())

        fun getRootAsOSBuild(
            _bb: ByteBuffer,
            obj: OSBuild,
        ): OSBuild {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createOSBuild(
            builder: FlatBufferBuilder,
            versionOffset: Int,
            brandOffset: Int,
            fingerprintOffset: Int,
            kernOsversionOffset: Int,
        ): Int {
            builder.startTable(4)
            addKernOsversion(builder, kernOsversionOffset)
            addFingerprint(builder, fingerprintOffset)
            addBrand(builder, brandOffset)
            addVersion(builder, versionOffset)
            return endOSBuild(builder)
        }

        fun startOSBuild(builder: FlatBufferBuilder) = builder.startTable(4)

        fun addVersion(
            builder: FlatBufferBuilder,
            version: Int,
        ) = builder.addOffset(0, version, 0)

        fun addBrand(
            builder: FlatBufferBuilder,
            brand: Int,
        ) = builder.addOffset(1, brand, 0)

        fun addFingerprint(
            builder: FlatBufferBuilder,
            fingerprint: Int,
        ) = builder.addOffset(2, fingerprint, 0)

        fun addKernOsversion(
            builder: FlatBufferBuilder,
            kernOsversion: Int,
        ) = builder.addOffset(3, kernOsversion, 0)

        fun endOSBuild(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class PowerMetrics : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): PowerMetrics {
        __init(_i, _bb)
        return this
    }

    val powerState: Byte
        get() {
            val o = __offset(4)
            return if (o != 0) bb.get(o + bb_pos) else 0
        }
    val chargePercent: UByte
        get() {
            val o = __offset(6)
            return if (o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsPowerMetrics(_bb: ByteBuffer): PowerMetrics = getRootAsPowerMetrics(_bb, PowerMetrics())

        fun getRootAsPowerMetrics(
            _bb: ByteBuffer,
            obj: PowerMetrics,
        ): PowerMetrics {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createPowerMetrics(
            builder: FlatBufferBuilder,
            powerState: Byte,
            chargePercent: UByte,
        ): Int {
            builder.startTable(2)
            addChargePercent(builder, chargePercent)
            addPowerState(builder, powerState)
            return endPowerMetrics(builder)
        }

        fun startPowerMetrics(builder: FlatBufferBuilder) = builder.startTable(2)

        fun addPowerState(
            builder: FlatBufferBuilder,
            powerState: Byte,
        ) = builder.addByte(0, powerState, 0)

        fun addChargePercent(
            builder: FlatBufferBuilder,
            chargePercent: UByte,
        ) = builder.addByte(1, chargePercent.toByte(), 0)

        fun endPowerMetrics(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class Display : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): Display {
        __init(_i, _bb)
        return this
    }

    val height: UInt
        get() {
            val o = __offset(4)
            return if (o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val width: UInt
        get() {
            val o = __offset(6)
            return if (o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val densityDpi: UInt
        get() {
            val o = __offset(8)
            return if (o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsDisplay(_bb: ByteBuffer): Display = getRootAsDisplay(_bb, Display())

        fun getRootAsDisplay(
            _bb: ByteBuffer,
            obj: Display,
        ): Display {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createDisplay(
            builder: FlatBufferBuilder,
            height: UInt,
            width: UInt,
            densityDpi: UInt,
        ): Int {
            builder.startTable(3)
            addDensityDpi(builder, densityDpi)
            addWidth(builder, width)
            addHeight(builder, height)
            return endDisplay(builder)
        }

        fun startDisplay(builder: FlatBufferBuilder) = builder.startTable(3)

        fun addHeight(
            builder: FlatBufferBuilder,
            height: UInt,
        ) = builder.addInt(0, height.toInt(), 0)

        fun addWidth(
            builder: FlatBufferBuilder,
            width: UInt,
        ) = builder.addInt(1, width.toInt(), 0)

        fun addDensityDpi(
            builder: FlatBufferBuilder,
            densityDpi: UInt,
        ) = builder.addInt(2, densityDpi.toInt(), 0)

        fun endDisplay(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class DeviceMetrics : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): DeviceMetrics {
        __init(_i, _bb)
        return this
    }

    val time: io.bitdrift.capture.reports.binformat.v1.issue_reporting.Timestamp? get() =
        time(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .Timestamp(),
        )

    fun time(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.Timestamp,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.Timestamp? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(o + bb_pos, bb)
        } else {
            null
        }
    }

    val timezone: String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val timezoneAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(6, 1)

    fun timezoneInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)

    val powerMetrics: io.bitdrift.capture.reports.binformat.v1.issue_reporting.PowerMetrics? get() =
        powerMetrics(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .PowerMetrics(),
        )

    fun powerMetrics(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.PowerMetrics,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.PowerMetrics? {
        val o = __offset(8)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    val networkState: Byte
        get() {
            val o = __offset(10)
            return if (o != 0) bb.get(o + bb_pos) else 0
        }
    val rotation: Byte
        get() {
            val o = __offset(12)
            return if (o != 0) bb.get(o + bb_pos) else 0
        }
    val arch: Byte
        get() {
            val o = __offset(14)
            return if (o != 0) bb.get(o + bb_pos) else 0
        }
    val display: io.bitdrift.capture.reports.binformat.v1.issue_reporting.Display? get() =
        display(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .Display(),
        )

    fun display(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.Display,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.Display? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    val manufacturer: String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val manufacturerAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(18, 1)

    fun manufacturerInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)

    val model: String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val modelAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(20, 1)

    fun modelInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)

    val osBuild: io.bitdrift.capture.reports.binformat.v1.issue_reporting.OSBuild? get() =
        osBuild(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .OSBuild(),
        )

    fun osBuild(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.OSBuild,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.OSBuild? {
        val o = __offset(22)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    val platform: Byte
        get() {
            val o = __offset(24)
            return if (o != 0) bb.get(o + bb_pos) else 0
        }

    fun cpuAbis(j: Int): String? {
        val o = __offset(26)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }

    val cpuAbisLength: Int
        get() {
            val o = __offset(26)
            return if (o != 0) __vector_len(o) else 0
        }
    val lowPowerModeEnabled: Boolean
        get() {
            val o = __offset(28)
            return if (o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val cpuUsage: io.bitdrift.capture.reports.binformat.v1.issue_reporting.ProcessorUsage? get() =
        cpuUsage(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .ProcessorUsage(),
        )

    fun cpuUsage(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.ProcessorUsage,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.ProcessorUsage? {
        val o = __offset(30)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    val thermalState: UByte
        get() {
            val o = __offset(32)
            return if (o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsDeviceMetrics(_bb: ByteBuffer): DeviceMetrics = getRootAsDeviceMetrics(_bb, DeviceMetrics())

        fun getRootAsDeviceMetrics(
            _bb: ByteBuffer,
            obj: DeviceMetrics,
        ): DeviceMetrics {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun startDeviceMetrics(builder: FlatBufferBuilder) = builder.startTable(15)

        fun addTime(
            builder: FlatBufferBuilder,
            time: Int,
        ) = builder.addStruct(0, time, 0)

        fun addTimezone(
            builder: FlatBufferBuilder,
            timezone: Int,
        ) = builder.addOffset(1, timezone, 0)

        fun addPowerMetrics(
            builder: FlatBufferBuilder,
            powerMetrics: Int,
        ) = builder.addOffset(2, powerMetrics, 0)

        fun addNetworkState(
            builder: FlatBufferBuilder,
            networkState: Byte,
        ) = builder.addByte(3, networkState, 0)

        fun addRotation(
            builder: FlatBufferBuilder,
            rotation: Byte,
        ) = builder.addByte(4, rotation, 0)

        fun addArch(
            builder: FlatBufferBuilder,
            arch: Byte,
        ) = builder.addByte(5, arch, 0)

        fun addDisplay(
            builder: FlatBufferBuilder,
            display: Int,
        ) = builder.addOffset(6, display, 0)

        fun addManufacturer(
            builder: FlatBufferBuilder,
            manufacturer: Int,
        ) = builder.addOffset(7, manufacturer, 0)

        fun addModel(
            builder: FlatBufferBuilder,
            model: Int,
        ) = builder.addOffset(8, model, 0)

        fun addOsBuild(
            builder: FlatBufferBuilder,
            osBuild: Int,
        ) = builder.addOffset(9, osBuild, 0)

        fun addPlatform(
            builder: FlatBufferBuilder,
            platform: Byte,
        ) = builder.addByte(10, platform, 0)

        fun addCpuAbis(
            builder: FlatBufferBuilder,
            cpuAbis: Int,
        ) = builder.addOffset(11, cpuAbis, 0)

        fun createCpuAbisVector(
            builder: FlatBufferBuilder,
            data: IntArray,
        ): Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startCpuAbisVector(
            builder: FlatBufferBuilder,
            numElems: Int,
        ) = builder.startVector(4, numElems, 4)

        fun addLowPowerModeEnabled(
            builder: FlatBufferBuilder,
            lowPowerModeEnabled: Boolean,
        ) = builder.addBoolean(12, lowPowerModeEnabled, false)

        fun addCpuUsage(
            builder: FlatBufferBuilder,
            cpuUsage: Int,
        ) = builder.addOffset(13, cpuUsage, 0)

        fun addThermalState(
            builder: FlatBufferBuilder,
            thermalState: UByte,
        ) = builder.addByte(14, thermalState.toByte(), 0)

        fun endDeviceMetrics(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class SourceFile : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): SourceFile {
        __init(_i, _bb)
        return this
    }

    val path: String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val pathAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(4, 1)

    fun pathInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)

    val line: Long
        get() {
            val o = __offset(6)
            return if (o != 0) bb.getLong(o + bb_pos) else 0L
        }
    val column: Long
        get() {
            val o = __offset(8)
            return if (o != 0) bb.getLong(o + bb_pos) else 0L
        }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsSourceFile(_bb: ByteBuffer): SourceFile = getRootAsSourceFile(_bb, SourceFile())

        fun getRootAsSourceFile(
            _bb: ByteBuffer,
            obj: SourceFile,
        ): SourceFile {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createSourceFile(
            builder: FlatBufferBuilder,
            pathOffset: Int,
            line: Long,
            column: Long,
        ): Int {
            builder.startTable(3)
            addColumn(builder, column)
            addLine(builder, line)
            addPath(builder, pathOffset)
            return endSourceFile(builder)
        }

        fun startSourceFile(builder: FlatBufferBuilder) = builder.startTable(3)

        fun addPath(
            builder: FlatBufferBuilder,
            path: Int,
        ) = builder.addOffset(0, path, 0)

        fun addLine(
            builder: FlatBufferBuilder,
            line: Long,
        ) = builder.addLong(1, line, 0L)

        fun addColumn(
            builder: FlatBufferBuilder,
            column: Long,
        ) = builder.addLong(2, column, 0L)

        fun endSourceFile(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class CPURegister : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): CPURegister {
        __init(_i, _bb)
        return this
    }

    val name: String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val nameAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(4, 1)

    fun nameInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)

    val value: ULong
        get() {
            val o = __offset(6)
            return if (o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsCPURegister(_bb: ByteBuffer): CPURegister = getRootAsCPURegister(_bb, CPURegister())

        fun getRootAsCPURegister(
            _bb: ByteBuffer,
            obj: CPURegister,
        ): CPURegister {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createCPURegister(
            builder: FlatBufferBuilder,
            nameOffset: Int,
            value: ULong,
        ): Int {
            builder.startTable(2)
            addValue(builder, value)
            addName(builder, nameOffset)
            return endCPURegister(builder)
        }

        fun startCPURegister(builder: FlatBufferBuilder) = builder.startTable(2)

        fun addName(
            builder: FlatBufferBuilder,
            name: Int,
        ) = builder.addOffset(0, name, 0)

        fun addValue(
            builder: FlatBufferBuilder,
            value: ULong,
        ) = builder.addLong(1, value.toLong(), 0)

        fun endCPURegister(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class Frame : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): Frame {
        __init(_i, _bb)
        return this
    }

    val type: Byte
        get() {
            val o = __offset(4)
            return if (o != 0) bb.get(o + bb_pos) else 0
        }
    val className: String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val classNameAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(6, 1)

    fun classNameInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)

    val symbolName: String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val symbolNameAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(8, 1)

    fun symbolNameInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)

    val sourceFile: io.bitdrift.capture.reports.binformat.v1.issue_reporting.SourceFile? get() =
        sourceFile(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .SourceFile(),
        )

    fun sourceFile(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.SourceFile,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.SourceFile? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    val imageId: String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val imageIdAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(12, 1)

    fun imageIdInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)

    val frameAddress: ULong
        get() {
            val o = __offset(14)
            return if (o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    val symbolAddress: ULong
        get() {
            val o = __offset(16)
            return if (o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }

    fun registers(j: Int): io.bitdrift.capture.reports.binformat.v1.issue_reporting.CPURegister? =
        registers(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .CPURegister(),
            j,
        )

    fun registers(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.CPURegister,
        j: Int,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.CPURegister? {
        val o = __offset(18)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }

    val registersLength: Int
        get() {
            val o = __offset(18)
            return if (o != 0) __vector_len(o) else 0
        }

    fun state(j: Int): String? {
        val o = __offset(20)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }

    val stateLength: Int
        get() {
            val o = __offset(20)
            return if (o != 0) __vector_len(o) else 0
        }
    val frameStatus: Byte
        get() {
            val o = __offset(22)
            return if (o != 0) bb.get(o + bb_pos) else 0
        }
    val originalIndex: ULong
        get() {
            val o = __offset(24)
            return if (o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    val inApp: Boolean
        get() {
            val o = __offset(26)
            return if (o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val symbolicatedName: String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val symbolicatedNameAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(28, 1)

    fun symbolicatedNameInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)

    val jsBundlePath: String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val jsBundlePathAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(30, 1)

    fun jsBundlePathInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsFrame(_bb: ByteBuffer): Frame = getRootAsFrame(_bb, Frame())

        fun getRootAsFrame(
            _bb: ByteBuffer,
            obj: Frame,
        ): Frame {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createFrame(
            builder: FlatBufferBuilder,
            type: Byte,
            classNameOffset: Int,
            symbolNameOffset: Int,
            sourceFileOffset: Int,
            imageIdOffset: Int,
            frameAddress: ULong,
            symbolAddress: ULong,
            registersOffset: Int,
            stateOffset: Int,
            frameStatus: Byte,
            originalIndex: ULong,
            inApp: Boolean,
            symbolicatedNameOffset: Int,
            jsBundlePathOffset: Int,
        ): Int {
            builder.startTable(14)
            addOriginalIndex(builder, originalIndex)
            addSymbolAddress(builder, symbolAddress)
            addFrameAddress(builder, frameAddress)
            addJsBundlePath(builder, jsBundlePathOffset)
            addSymbolicatedName(builder, symbolicatedNameOffset)
            addState(builder, stateOffset)
            addRegisters(builder, registersOffset)
            addImageId(builder, imageIdOffset)
            addSourceFile(builder, sourceFileOffset)
            addSymbolName(builder, symbolNameOffset)
            addClassName(builder, classNameOffset)
            addInApp(builder, inApp)
            addFrameStatus(builder, frameStatus)
            addType(builder, type)
            return endFrame(builder)
        }

        fun startFrame(builder: FlatBufferBuilder) = builder.startTable(14)

        fun addType(
            builder: FlatBufferBuilder,
            type: Byte,
        ) = builder.addByte(0, type, 0)

        fun addClassName(
            builder: FlatBufferBuilder,
            className: Int,
        ) = builder.addOffset(1, className, 0)

        fun addSymbolName(
            builder: FlatBufferBuilder,
            symbolName: Int,
        ) = builder.addOffset(2, symbolName, 0)

        fun addSourceFile(
            builder: FlatBufferBuilder,
            sourceFile: Int,
        ) = builder.addOffset(3, sourceFile, 0)

        fun addImageId(
            builder: FlatBufferBuilder,
            imageId: Int,
        ) = builder.addOffset(4, imageId, 0)

        fun addFrameAddress(
            builder: FlatBufferBuilder,
            frameAddress: ULong,
        ) = builder.addLong(5, frameAddress.toLong(), 0)

        fun addSymbolAddress(
            builder: FlatBufferBuilder,
            symbolAddress: ULong,
        ) = builder.addLong(6, symbolAddress.toLong(), 0)

        fun addRegisters(
            builder: FlatBufferBuilder,
            registers: Int,
        ) = builder.addOffset(7, registers, 0)

        fun createRegistersVector(
            builder: FlatBufferBuilder,
            data: IntArray,
        ): Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startRegistersVector(
            builder: FlatBufferBuilder,
            numElems: Int,
        ) = builder.startVector(4, numElems, 4)

        fun addState(
            builder: FlatBufferBuilder,
            state: Int,
        ) = builder.addOffset(8, state, 0)

        fun createStateVector(
            builder: FlatBufferBuilder,
            data: IntArray,
        ): Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startStateVector(
            builder: FlatBufferBuilder,
            numElems: Int,
        ) = builder.startVector(4, numElems, 4)

        fun addFrameStatus(
            builder: FlatBufferBuilder,
            frameStatus: Byte,
        ) = builder.addByte(9, frameStatus, 0)

        fun addOriginalIndex(
            builder: FlatBufferBuilder,
            originalIndex: ULong,
        ) = builder.addLong(10, originalIndex.toLong(), 0)

        fun addInApp(
            builder: FlatBufferBuilder,
            inApp: Boolean,
        ) = builder.addBoolean(11, inApp, false)

        fun addSymbolicatedName(
            builder: FlatBufferBuilder,
            symbolicatedName: Int,
        ) = builder.addOffset(12, symbolicatedName, 0)

        fun addJsBundlePath(
            builder: FlatBufferBuilder,
            jsBundlePath: Int,
        ) = builder.addOffset(13, jsBundlePath, 0)

        fun endFrame(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class Thread : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): Thread {
        __init(_i, _bb)
        return this
    }

    val name: String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val nameAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(4, 1)

    fun nameInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)

    val active: Boolean
        get() {
            val o = __offset(6)
            return if (o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val index: UInt
        get() {
            val o = __offset(8)
            return if (o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val state: String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val stateAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(10, 1)

    fun stateInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)

    val priority: Float
        get() {
            val o = __offset(12)
            return if (o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val qualityOfService: Byte
        get() {
            val o = __offset(14)
            return if (o != 0) bb.get(o + bb_pos) else -1
        }

    fun stackTrace(j: Int): io.bitdrift.capture.reports.binformat.v1.issue_reporting.Frame? =
        stackTrace(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .Frame(),
            j,
        )

    fun stackTrace(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.Frame,
        j: Int,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.Frame? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }

    val stackTraceLength: Int
        get() {
            val o = __offset(16)
            return if (o != 0) __vector_len(o) else 0
        }
    val summary: String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val summaryAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(18, 1)

    fun summaryInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsThread(_bb: ByteBuffer): Thread = getRootAsThread(_bb, Thread())

        fun getRootAsThread(
            _bb: ByteBuffer,
            obj: Thread,
        ): Thread {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createThread(
            builder: FlatBufferBuilder,
            nameOffset: Int,
            active: Boolean,
            index: UInt,
            stateOffset: Int,
            priority: Float,
            qualityOfService: Byte,
            stackTraceOffset: Int,
            summaryOffset: Int,
        ): Int {
            builder.startTable(8)
            addSummary(builder, summaryOffset)
            addStackTrace(builder, stackTraceOffset)
            addPriority(builder, priority)
            addState(builder, stateOffset)
            addIndex(builder, index)
            addName(builder, nameOffset)
            addQualityOfService(builder, qualityOfService)
            addActive(builder, active)
            return endThread(builder)
        }

        fun startThread(builder: FlatBufferBuilder) = builder.startTable(8)

        fun addName(
            builder: FlatBufferBuilder,
            name: Int,
        ) = builder.addOffset(0, name, 0)

        fun addActive(
            builder: FlatBufferBuilder,
            active: Boolean,
        ) = builder.addBoolean(1, active, false)

        fun addIndex(
            builder: FlatBufferBuilder,
            index: UInt,
        ) = builder.addInt(2, index.toInt(), 0)

        fun addState(
            builder: FlatBufferBuilder,
            state: Int,
        ) = builder.addOffset(3, state, 0)

        fun addPriority(
            builder: FlatBufferBuilder,
            priority: Float,
        ) = builder.addFloat(4, priority, 0.0)

        fun addQualityOfService(
            builder: FlatBufferBuilder,
            qualityOfService: Byte,
        ) = builder.addByte(5, qualityOfService, -1)

        fun addStackTrace(
            builder: FlatBufferBuilder,
            stackTrace: Int,
        ) = builder.addOffset(6, stackTrace, 0)

        fun createStackTraceVector(
            builder: FlatBufferBuilder,
            data: IntArray,
        ): Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startStackTraceVector(
            builder: FlatBufferBuilder,
            numElems: Int,
        ) = builder.startVector(4, numElems, 4)

        fun addSummary(
            builder: FlatBufferBuilder,
            summary: Int,
        ) = builder.addOffset(7, summary, 0)

        fun endThread(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class ThreadDetails : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): ThreadDetails {
        __init(_i, _bb)
        return this
    }

    val count: UShort
        get() {
            val o = __offset(4)
            return if (o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }

    fun threads(j: Int): io.bitdrift.capture.reports.binformat.v1.issue_reporting.Thread? =
        threads(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .Thread(),
            j,
        )

    fun threads(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.Thread,
        j: Int,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.Thread? {
        val o = __offset(6)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }

    val threadsLength: Int
        get() {
            val o = __offset(6)
            return if (o != 0) __vector_len(o) else 0
        }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsThreadDetails(_bb: ByteBuffer): ThreadDetails = getRootAsThreadDetails(_bb, ThreadDetails())

        fun getRootAsThreadDetails(
            _bb: ByteBuffer,
            obj: ThreadDetails,
        ): ThreadDetails {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createThreadDetails(
            builder: FlatBufferBuilder,
            count: UShort,
            threadsOffset: Int,
        ): Int {
            builder.startTable(2)
            addThreads(builder, threadsOffset)
            addCount(builder, count)
            return endThreadDetails(builder)
        }

        fun startThreadDetails(builder: FlatBufferBuilder) = builder.startTable(2)

        fun addCount(
            builder: FlatBufferBuilder,
            count: UShort,
        ) = builder.addShort(0, count.toShort(), 0)

        fun addThreads(
            builder: FlatBufferBuilder,
            threads: Int,
        ) = builder.addOffset(1, threads, 0)

        fun createThreadsVector(
            builder: FlatBufferBuilder,
            data: IntArray,
        ): Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startThreadsVector(
            builder: FlatBufferBuilder,
            numElems: Int,
        ) = builder.startVector(4, numElems, 4)

        fun endThreadDetails(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class Error : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): Error {
        __init(_i, _bb)
        return this
    }

    val name: String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val nameAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(4, 1)

    fun nameInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)

    val reason: String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val reasonAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(6, 1)

    fun reasonInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)

    fun stackTrace(j: Int): io.bitdrift.capture.reports.binformat.v1.issue_reporting.Frame? =
        stackTrace(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .Frame(),
            j,
        )

    fun stackTrace(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.Frame,
        j: Int,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.Frame? {
        val o = __offset(8)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }

    val stackTraceLength: Int
        get() {
            val o = __offset(8)
            return if (o != 0) __vector_len(o) else 0
        }
    val relationToNext: Byte
        get() {
            val o = __offset(10)
            return if (o != 0) bb.get(o + bb_pos) else 1
        }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsError(_bb: ByteBuffer): Error = getRootAsError(_bb, Error())

        fun getRootAsError(
            _bb: ByteBuffer,
            obj: Error,
        ): Error {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createError(
            builder: FlatBufferBuilder,
            nameOffset: Int,
            reasonOffset: Int,
            stackTraceOffset: Int,
            relationToNext: Byte,
        ): Int {
            builder.startTable(4)
            addStackTrace(builder, stackTraceOffset)
            addReason(builder, reasonOffset)
            addName(builder, nameOffset)
            addRelationToNext(builder, relationToNext)
            return endError(builder)
        }

        fun startError(builder: FlatBufferBuilder) = builder.startTable(4)

        fun addName(
            builder: FlatBufferBuilder,
            name: Int,
        ) = builder.addOffset(0, name, 0)

        fun addReason(
            builder: FlatBufferBuilder,
            reason: Int,
        ) = builder.addOffset(1, reason, 0)

        fun addStackTrace(
            builder: FlatBufferBuilder,
            stackTrace: Int,
        ) = builder.addOffset(2, stackTrace, 0)

        fun createStackTraceVector(
            builder: FlatBufferBuilder,
            data: IntArray,
        ): Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startStackTraceVector(
            builder: FlatBufferBuilder,
            numElems: Int,
        ) = builder.startVector(4, numElems, 4)

        fun addRelationToNext(
            builder: FlatBufferBuilder,
            relationToNext: Byte,
        ) = builder.addByte(3, relationToNext, 1)

        fun endError(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class BinaryImage : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): BinaryImage {
        __init(_i, _bb)
        return this
    }

    val id: String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(4, 1)

    fun idInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)

    val path: String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val pathAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(6, 1)

    fun pathInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)

    val loadAddress: ULong
        get() {
            val o = __offset(8)
            return if (o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsBinaryImage(_bb: ByteBuffer): BinaryImage = getRootAsBinaryImage(_bb, BinaryImage())

        fun getRootAsBinaryImage(
            _bb: ByteBuffer,
            obj: BinaryImage,
        ): BinaryImage {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createBinaryImage(
            builder: FlatBufferBuilder,
            idOffset: Int,
            pathOffset: Int,
            loadAddress: ULong,
        ): Int {
            builder.startTable(3)
            addLoadAddress(builder, loadAddress)
            addPath(builder, pathOffset)
            addId(builder, idOffset)
            return endBinaryImage(builder)
        }

        fun startBinaryImage(builder: FlatBufferBuilder) = builder.startTable(3)

        fun addId(
            builder: FlatBufferBuilder,
            id: Int,
        ) = builder.addOffset(0, id, 0)

        fun addPath(
            builder: FlatBufferBuilder,
            path: Int,
        ) = builder.addOffset(1, path, 0)

        fun addLoadAddress(
            builder: FlatBufferBuilder,
            loadAddress: ULong,
        ) = builder.addLong(2, loadAddress.toLong(), 0)

        fun endBinaryImage(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class SDKInfo : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): SDKInfo {
        __init(_i, _bb)
        return this
    }

    val id: String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val idAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(4, 1)

    fun idInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)

    val version: String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val versionAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(6, 1)

    fun versionInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsSDKInfo(_bb: ByteBuffer): SDKInfo = getRootAsSDKInfo(_bb, SDKInfo())

        fun getRootAsSDKInfo(
            _bb: ByteBuffer,
            obj: SDKInfo,
        ): SDKInfo {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createSDKInfo(
            builder: FlatBufferBuilder,
            idOffset: Int,
            versionOffset: Int,
        ): Int {
            builder.startTable(2)
            addVersion(builder, versionOffset)
            addId(builder, idOffset)
            return endSDKInfo(builder)
        }

        fun startSDKInfo(builder: FlatBufferBuilder) = builder.startTable(2)

        fun addId(
            builder: FlatBufferBuilder,
            id: Int,
        ) = builder.addOffset(0, id, 0)

        fun addVersion(
            builder: FlatBufferBuilder,
            version: Int,
        ) = builder.addOffset(1, version, 0)

        fun endSDKInfo(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class FeatureFlag : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): FeatureFlag {
        __init(_i, _bb)
        return this
    }

    val name: String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val nameAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(4, 1)

    fun nameInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)

    val value: String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val valueAsByteBuffer: ByteBuffer get() = __vector_as_bytebuffer(6, 1)

    fun valueInByteBuffer(_bb: ByteBuffer): ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)

    val timestamp: io.bitdrift.capture.reports.binformat.v1.common.Timestamp? get() =
        timestamp(
            io.bitdrift.capture.reports.binformat.v1.common
                .Timestamp(),
        )

    fun timestamp(
        obj: io.bitdrift.capture.reports.binformat.v1.common.Timestamp,
    ): io.bitdrift.capture.reports.binformat.v1.common.Timestamp? {
        val o = __offset(8)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsFeatureFlag(_bb: ByteBuffer): FeatureFlag = getRootAsFeatureFlag(_bb, FeatureFlag())

        fun getRootAsFeatureFlag(
            _bb: ByteBuffer,
            obj: FeatureFlag,
        ): FeatureFlag {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createFeatureFlag(
            builder: FlatBufferBuilder,
            nameOffset: Int,
            valueOffset: Int,
            timestampOffset: Int,
        ): Int {
            builder.startTable(3)
            addTimestamp(builder, timestampOffset)
            addValue(builder, valueOffset)
            addName(builder, nameOffset)
            return endFeatureFlag(builder)
        }

        fun startFeatureFlag(builder: FlatBufferBuilder) = builder.startTable(3)

        fun addName(
            builder: FlatBufferBuilder,
            name: Int,
        ) = builder.addOffset(0, name, 0)

        fun addValue(
            builder: FlatBufferBuilder,
            value: Int,
        ) = builder.addOffset(1, value, 0)

        fun addTimestamp(
            builder: FlatBufferBuilder,
            timestamp: Int,
        ) = builder.addOffset(2, timestamp, 0)

        fun endFeatureFlag(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }
    }
}

@Suppress("unused")
class Report : Table() {
    fun __init(
        _i: Int,
        _bb: ByteBuffer,
    ) {
        __reset(_i, _bb)
    }

    fun __assign(
        _i: Int,
        _bb: ByteBuffer,
    ): Report {
        __init(_i, _bb)
        return this
    }

    val sdk: io.bitdrift.capture.reports.binformat.v1.issue_reporting.SDKInfo? get() =
        sdk(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .SDKInfo(),
        )

    fun sdk(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.SDKInfo,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.SDKInfo? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    val type: Byte
        get() {
            val o = __offset(6)
            return if (o != 0) bb.get(o + bb_pos) else 0
        }
    val appMetrics: io.bitdrift.capture.reports.binformat.v1.issue_reporting.AppMetrics? get() =
        appMetrics(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .AppMetrics(),
        )

    fun appMetrics(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.AppMetrics,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.AppMetrics? {
        val o = __offset(8)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    val deviceMetrics: io.bitdrift.capture.reports.binformat.v1.issue_reporting.DeviceMetrics? get() =
        deviceMetrics(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .DeviceMetrics(),
        )

    fun deviceMetrics(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.DeviceMetrics,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.DeviceMetrics? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    fun errors(j: Int): io.bitdrift.capture.reports.binformat.v1.issue_reporting.Error? =
        errors(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .Error(),
            j,
        )

    fun errors(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.Error,
        j: Int,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.Error? {
        val o = __offset(12)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }

    val errorsLength: Int
        get() {
            val o = __offset(12)
            return if (o != 0) __vector_len(o) else 0
        }
    val threadDetails: io.bitdrift.capture.reports.binformat.v1.issue_reporting.ThreadDetails? get() =
        threadDetails(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .ThreadDetails(),
        )

    fun threadDetails(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.ThreadDetails,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.ThreadDetails? {
        val o = __offset(14)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }

    fun binaryImages(j: Int): io.bitdrift.capture.reports.binformat.v1.issue_reporting.BinaryImage? =
        binaryImages(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .BinaryImage(),
            j,
        )

    fun binaryImages(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.BinaryImage,
        j: Int,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.BinaryImage? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }

    val binaryImagesLength: Int
        get() {
            val o = __offset(16)
            return if (o != 0) __vector_len(o) else 0
        }

    fun state(j: Int): io.bitdrift.capture.reports.binformat.v1.common.Field? =
        state(
            io.bitdrift.capture.reports.binformat.v1.common
                .Field(),
            j,
        )

    fun state(
        obj: io.bitdrift.capture.reports.binformat.v1.common.Field,
        j: Int,
    ): io.bitdrift.capture.reports.binformat.v1.common.Field? {
        val o = __offset(18)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }

    val stateLength: Int
        get() {
            val o = __offset(18)
            return if (o != 0) __vector_len(o) else 0
        }

    fun featureFlags(j: Int): io.bitdrift.capture.reports.binformat.v1.issue_reporting.FeatureFlag? =
        featureFlags(
            io.bitdrift.capture.reports.binformat.v1.issue_reporting
                .FeatureFlag(),
            j,
        )

    fun featureFlags(
        obj: io.bitdrift.capture.reports.binformat.v1.issue_reporting.FeatureFlag,
        j: Int,
    ): io.bitdrift.capture.reports.binformat.v1.issue_reporting.FeatureFlag? {
        val o = __offset(20)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }

    val featureFlagsLength: Int
        get() {
            val o = __offset(20)
            return if (o != 0) __vector_len(o) else 0
        }

    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()

        fun getRootAsReport(_bb: ByteBuffer): Report = getRootAsReport(_bb, Report())

        fun getRootAsReport(
            _bb: ByteBuffer,
            obj: Report,
        ): Report {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }

        fun createReport(
            builder: FlatBufferBuilder,
            sdkOffset: Int,
            type: Byte,
            appMetricsOffset: Int,
            deviceMetricsOffset: Int,
            errorsOffset: Int,
            threadDetailsOffset: Int,
            binaryImagesOffset: Int,
            stateOffset: Int,
            featureFlagsOffset: Int,
        ): Int {
            builder.startTable(9)
            addFeatureFlags(builder, featureFlagsOffset)
            addState(builder, stateOffset)
            addBinaryImages(builder, binaryImagesOffset)
            addThreadDetails(builder, threadDetailsOffset)
            addErrors(builder, errorsOffset)
            addDeviceMetrics(builder, deviceMetricsOffset)
            addAppMetrics(builder, appMetricsOffset)
            addSdk(builder, sdkOffset)
            addType(builder, type)
            return endReport(builder)
        }

        fun startReport(builder: FlatBufferBuilder) = builder.startTable(9)

        fun addSdk(
            builder: FlatBufferBuilder,
            sdk: Int,
        ) = builder.addOffset(0, sdk, 0)

        fun addType(
            builder: FlatBufferBuilder,
            type: Byte,
        ) = builder.addByte(1, type, 0)

        fun addAppMetrics(
            builder: FlatBufferBuilder,
            appMetrics: Int,
        ) = builder.addOffset(2, appMetrics, 0)

        fun addDeviceMetrics(
            builder: FlatBufferBuilder,
            deviceMetrics: Int,
        ) = builder.addOffset(3, deviceMetrics, 0)

        fun addErrors(
            builder: FlatBufferBuilder,
            errors: Int,
        ) = builder.addOffset(4, errors, 0)

        fun createErrorsVector(
            builder: FlatBufferBuilder,
            data: IntArray,
        ): Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startErrorsVector(
            builder: FlatBufferBuilder,
            numElems: Int,
        ) = builder.startVector(4, numElems, 4)

        fun addThreadDetails(
            builder: FlatBufferBuilder,
            threadDetails: Int,
        ) = builder.addOffset(5, threadDetails, 0)

        fun addBinaryImages(
            builder: FlatBufferBuilder,
            binaryImages: Int,
        ) = builder.addOffset(6, binaryImages, 0)

        fun createBinaryImagesVector(
            builder: FlatBufferBuilder,
            data: IntArray,
        ): Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startBinaryImagesVector(
            builder: FlatBufferBuilder,
            numElems: Int,
        ) = builder.startVector(4, numElems, 4)

        fun addState(
            builder: FlatBufferBuilder,
            state: Int,
        ) = builder.addOffset(7, state, 0)

        fun createStateVector(
            builder: FlatBufferBuilder,
            data: IntArray,
        ): Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startStateVector(
            builder: FlatBufferBuilder,
            numElems: Int,
        ) = builder.startVector(4, numElems, 4)

        fun addFeatureFlags(
            builder: FlatBufferBuilder,
            featureFlags: Int,
        ) = builder.addOffset(8, featureFlags, 0)

        fun createFeatureFlagsVector(
            builder: FlatBufferBuilder,
            data: IntArray,
        ): Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startFeatureFlagsVector(
            builder: FlatBufferBuilder,
            numElems: Int,
        ) = builder.startVector(4, numElems, 4)

        fun endReport(builder: FlatBufferBuilder): Int {
            val o = builder.endTable()
            return o
        }

        fun finishReportBuffer(
            builder: FlatBufferBuilder,
            offset: Int,
        ) = builder.finish(offset)

        fun finishSizePrefixedReportBuffer(
            builder: FlatBufferBuilder,
            offset: Int,
        ) = builder.finishSizePrefixed(offset)
    }
}
